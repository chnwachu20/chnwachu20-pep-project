package DAO;
import Model.Message;

import Model.Account;
import Util.ConnectionUtil;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;
public class AccountDAO {
    
    /**
     * TODO: retrieve all accounts from the Account table.
     * You only need to change the sql String.
     * @return all Accounts.
     */
    public List<Account> getAllAccounts(){
        Connection connection = ConnectionUtil.getConnection();
        List<Account> accounts = new ArrayList<>();
        try {
            //Write SQL logic here
            String sql = "SELECT * FROM Account";
            PreparedStatement preparedStatement = connection.prepareStatement(sql);
            ResultSet rs = preparedStatement.executeQuery();
            while(rs.next()){
                Account account = new Account(rs.getString("username"), rs.getString("password"));
                accounts.add(account);
            }
        }catch(SQLException e){
            System.out.println(e.getMessage());
        }
        return accounts;
}

public Account UserLogin(String username, String password) {
    String sql = "SELECT * FROM Account WHERE username = ? AND password = ?";
    try (Connection connection = ConnectionUtil.getConnection();
         PreparedStatement preparedStatement = connection.prepareStatement(sql)) {

        preparedStatement.setString(1, username);
        preparedStatement.setString(2, password);

        ResultSet rs = preparedStatement.executeQuery();

        if (rs.next()) {
            return new Account(
                rs.getInt("account_id"),
                rs.getString("username"),
                rs.getString("password")
            );
        }
    } catch (SQLException e) {
        System.out.println("Error querying the database: " + e.getMessage());
    }
    return null; // Return null if no account is found
}

    /**
     * TODO: insert an account into the Account table.
     * The account_id should be automatically generated by the sql database if it is not provided because it was
     * set to auto_increment. Therefore, you only need to insert a record with a single column (name).
     * You only need to change the sql String and leverage PreparedStatements' setString methods.
     */
    public Account insertAccount(Account account) {
        String sql = "INSERT INTO Account(username, password) VALUES (?, ?)";
        try (Connection connection = ConnectionUtil.getConnection();
             PreparedStatement preparedStatement = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {
    
            preparedStatement.setString(1, account.getUsername());
            preparedStatement.setString(2, account.getPassword());
            int rowsAffected = preparedStatement.executeUpdate();
    
            // Retrieve the generated key (account_id) if the insertion was successful
            if (rowsAffected > 0) {
                ResultSet keys = preparedStatement.getGeneratedKeys();
                if (keys.next()) {
                    account.setAccount_id(keys.getInt(1)); // Set the generated account_id
                }
            } else {
                throw new SQLException("No rows affected during account insertion.");
            }
    
            return account;
    
        } catch (SQLException e) {
            System.err.println("Error inserting account: " + e.getMessage());
            return null;
        }
    }
    public static boolean doesUserExistByUsername(String username) {
        String sql = "SELECT 1 FROM Users WHERE username = ?"; // Assuming `Users` table with `user_id`
        try (Connection connection = ConnectionUtil.getConnection();
             PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
    
            preparedStatement.setString(1, username);
            ResultSet rs = preparedStatement.executeQuery();
    
            return rs.next(); // Returns true if a record is found, false otherwise
    
        } catch (SQLException e) {
            System.err.println("Error checking user existence: " + e.getMessage());
            return false;
        }
    }
    
    
}
